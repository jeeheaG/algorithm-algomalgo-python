# v1 : dp

'''
[문제 해석]
앞에서부터 숫자를 골라서 배열을 만들 때, 가장 원소 개수가 많은 순증가 배열은?
- 시간 제한 : 1초
** 순증가 : 계속 커지는 증가. 같거나 작으면 안됨

[구상]
5
8 9 1 2 10
-> 3개

8
5 4 3 2 1 6 7 8
-> 4개

부분 계산이 더 큰 계산으로 모일 수 있는 DP 관점으로 생각해야 한다!!!
배열을 돌면서 자기 이전에 자기자신보다 작은 수가 최대 몇개였는지 계산할 수 있음. dp배열과 max 함수 사용
점화식은.. 딱히 한 문장의 수식으로는 모르겠다. 이런 경우도 있네..
일단 풀어보자
'''

import sys
input = sys.stdin.readline

N = int(input())
nums = list(map(int, input().split()))

dp = [1] * N #현재 위치의 숫자가 배열의 마지막일때, 순증가 배열의 크기를 기록할 dp테이블

for i in range(N) : # 숫자 전체를 돌면서
    for j in range(i) : # 자기 이전 숫자들을 체크
        if nums[j] < nums[i] : # 체크중인 이전 수가 현재 수보다 작을 경우(순증가 성립)
            dp[i] = max(dp[i], dp[j]+1) # 이전 수의 최대배열 길이에 현재 수를 포함한 배열 길이들 중 제일 큰 값 저장

print(max(dp))
