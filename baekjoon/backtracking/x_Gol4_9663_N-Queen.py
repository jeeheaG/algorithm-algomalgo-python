# fail : 백트래킹
# 이 코드는 무한루프 돎 - 2차원 배열 써서 풀어보려했는데 잘 안됨. 어케하는지 궁금함..
# TS : 2차원 좌표는 1차원 배열에 저장할 수도 있다.
# TIP : 리스트 인덱스도 함께 반복문 돌고 싶을 떈 enumerate(리스트)

'''
[문제해석]
N-Queen : 크기가 NxN인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제
- N이 주어지고, N개를 놓을 수 있는 경우의 개수를 구하기
- 제한시간 : 10초 (뭐든 하라는 건가)
** 퀸은 가로세로대각선 어느방향으로든 원하는 만큼 이동할 수 있음

구상
- 체스판 2차원 행렬 0으로 초기화
- 퀸마다 체스판 전체 돌면서 0인 곳에 배치, 이번 퀸 배치로 퀸을 배치하지 못하게 된 칸들 +1해줌
- 이번 퀸 배치 성공 시 다음 퀸 배치는 dfs재귀
- 재귀에서 빠져나올 때는 ???어케 다시 되돌리지 체스판.. 
    1. 배치할때마다 새로 만드는 건 오바잔아
    2. 어떤 퀸 때문에 배치할 수 없는지 목록 적어둠. 수거할 때 해당되는 퀸인지 확인해서 제거
    3. 숫자 +1 해놓고 배치 제거할 퀸 좌표에 따라 해당되는 자리들 -1해줌 -> 이게 절충안인듯? 츄라이..
- 이번 퀸을 배치할 곳이 없으면 백트래킹
- N개의 퀸을 전부 배치했으면 set에
-??? 퀸이 다 같지 않나? 중복어떻게 없애지..



구상 2
- 배치한 퀸 좌표 목록을 저장함
- 체스판 좌표마다 이미 배치된 퀸 목록 돌며 배치 가능한 좌표인지 확인
- 가능하면 배치, dfs재귀
- 좌표목록을 중복체크 어케함... 1차원 배열 써야 되나봐 일단 그걸로 풀고 2차원 솔루션 찾아봐야지



솔루션 살짝 찾아봄 : 1차원 배열 솔루션
- 2차원 배열 정보를 꼭 2차원에 담아야 하는 건 아님. 인덱스 자체를 정보로 쓸 수도 있음
- (x,y) 좌표를 x=인덱스, y=값 으로 해서 그냥 리스트에 넣을 수도 있음 -> 이러면 튜플로 바꿔서 set에 넣어 중복체크도 가능함
- 퀸 배치 시 모든 퀸에 대해 배치가능한지 계산해줘야 되긴 하는데, 이정도 계산은 괜찮은가봄..
- 2차원 배열 써서도 풀 수 있는 것 같은데 궁금함..


구상 3
- 배치한 퀸 좌표를 1차원 배열에 저장
- 체스판 좌표마다 이미 배치된 퀸 목록 돌며 배치 가능한 좌표인지 확인(좌표값으로 계산)
    - TS : 체스판 좌표를 다 돌지 않아도 됨. 퀸 특징때문에 어차피 한 줄에 하나밖에 못놔서 행변호만 반복문 돌면 된다..
- 배치 가능하면 배치 후 dfs재귀
- 어디에도 배치 불가능하면 백트래킹
- n개 모두 배치했으면 튜플로 바꿔 set에 넣음
    - 중복 제거됨 : 퀸 입장에서의 좌표값 목록이 아니라 보드 입장에서 퀸의 위치를 기록한 리스트에 가까움. 인덱스별 값이 각 행에서의 퀸 위치를 의미하므로 같은 위치에 퀸들이 배치된 경우들은 같은 리스트가 됨!
- 답 : 모든 경우를 담아둔 set 원소개수로 반환

이 코드는 무한루프 돎
'''

N = int(input())

board = [-1]*N #배치한 퀸들 좌표 저장 x=인덱스, y=값
result = set() #n개 모두 배치 성공한 경우들 저장

def dfs(cnt) :
    if cnt == N :
        result.add(tuple(board))
        return

    #모든 좌표에 대해
    for i in range(N) :
        for j in range(N) :

            #배치할 수 있는 위치인지 모든 퀸을 확인
            able = True
            for x, y in enumerate(board) :
                #배치 안 된 행은 확인하지 않고 패스
                if y == -1 :
                    continue
                if i == x or j == y or abs(x-i) == abs(y-j) : #가로, 세로, 대각선 중 하나에 걸림
                    able = False
            
            #하나라도 걸리면 배치불가, 다른 좌표 탐색
            if not able :
                continue
            
            #배치 가능한 위치이면 배치하고 재귀
            board[i] = j
            dfs(cnt+1)
            board[i] = -1

dfs(0)

print(len(result))