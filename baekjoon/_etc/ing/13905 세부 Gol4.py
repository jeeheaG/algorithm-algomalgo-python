# v1 : MST

'''
[문제 해석]
출발 노드에서 도착 노드로 가는 경로 중, 거치는 간선 가중치의 최솟값이 가장 큰 경로를 구하기
- 시간 제한 1초


[솔루션 목록]

1. (시간초과)
bfs 돌면서 간선 최소값 들고다님
도착노드 만나면 bfs 종료, 간선 최소값을 그동안의 값이랑 비교해 최댓값구함
- 시간제한 : 1초
- N <= 10^5, M <= 3 * 10^5
    -> 그냥 bfs하면 시간초과

2.
크루스칼로 MST(Maximum)를 만들어둔 후에, 시작노드부터 도착노드까지의 bfs를 함
-> 오.. 기억해놓자 MST를 경로에 활용하는 법..
=> 요걸로 풀어본다

3. 
다익스트라

4. 
이분탐색 + BFS
무게 최대값을 찾기 위해 가능한 무게를 1~제한값 범위에서 이분탐색함. BFS돌면서 가능한지 확인함
-> ㅎ..ㄷㄷ



[구상] 
MST(Max) 를 구해놓은 뒤, 그 경로에서 bfs로 출발노드->도착노드 경로의 최소가중치를 구한다!

MST
- 간선 입력 받음. (가중치, 노드, 노드)
- Max니까 큰 순으로 정렬함
- union, find 함수 만듦
    - union : find로 중복인지 확인 후 간선먹음(트리합침)
    - find : 루트노드가 같은지 확인. 같으면 사이클생기므로 뱉음. with 경로압축
- 수행하면서 겹치지 않게 간선 먹음
- 간선 N-1개 먹었으면 끝

BFS
- MST에 사용된 간선만 탐색해서 출발->도착 경로 찾음
- 이 때 경로 최소 가중치 들고다님. 찾은 경로의 최소가중치가 답

'''

import sys
input = sys.stdin.readline

N, M = map(int, input().split())
S, E = map(int, input().split()) # 출발, 도착 노드




def union() :
